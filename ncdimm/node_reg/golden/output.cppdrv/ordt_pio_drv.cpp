//   Ordt 190524.01 autogenerated file 
//   Input: ./node_reg.rdl
//   Parms: ./node_reg.params
//   Date: Sun Dec 06 17:52:46 EST 2020
//

#include "ordt_pio_common.hpp"
#include "ordt_pio_drv.hpp"

// ------------------ ordt_drv_path_element methods ------------------

ordt_drv_path_element::ordt_drv_path_element(std::string _m_name, int _m_idx)
  : m_name(_m_name),
    m_idx(_m_idx) {
}

// ------------------ ordt_drv_field methods ------------------

ordt_drv_field::ordt_drv_field(std::string _m_name, int _m_loidx, int _m_width, bool _m_readable, bool _m_writeable)
  : m_name(_m_name),
    m_loidx(_m_loidx),
    m_width(_m_width),
    m_readable(_m_readable),
    m_writeable(_m_writeable) {
}

// ------------------ ordt_drv_element methods ------------------

std::list<std::string>  ordt_drv_element::split(const std::string &text, char sep, bool trim_rb) {
  std::list<std::string> tokens;
  std::size_t start = 0, end = 0, end_adj = 0;
  while ((end = text.find(sep, start)) != std::string::npos) {
    if (trim_rb && ((end_adj = text.find(']', start)) != std::string::npos) && (end_adj<end))
      tokens.push_back(text.substr(start, end_adj - start));
    else
      tokens.push_back(text.substr(start, end - start));
    start = end + 1;
  }
  if (trim_rb && ((end_adj = text.find(']', start)) != std::string::npos))
    tokens.push_back(text.substr(start, end_adj - start));
  else
    tokens.push_back(text.substr(start));
  return tokens;
}

int  ordt_drv_element::get_version(const std::string tag) {
  if (tag == "top") return 0;
  else return -1;
}

std::list<ordt_drv_path_element>  ordt_drv_element::get_path(const std::string pathstr) {
  std::list<ordt_drv_path_element> pathlist;
  std::list<std::string> lst = split(pathstr, '.', true);
  for(auto const& str_elem: lst) {
     std::list<std::string> sub_lst = split(str_elem, '[', false);
     if (sub_lst.size()==2) {
       pathlist.emplace_back(sub_lst.front(), std::stoi(sub_lst.back()));
     }
     else {
       pathlist.emplace_back(sub_lst.front(), 1);
     }
  }
  return pathlist;
}

ordt_drv_element::ordt_drv_element(std::string _m_name)
  : m_name(_m_name) {
}

int  ordt_drv_element::get_address_using_version(const int version, const std::string pathstr, uint64_t &address, std::list<ordt_drv_field> &fields) {
  std::list<ordt_drv_path_element> path = get_path(pathstr);
  if (path.size()>0) return get_address_using_list(version, path, false, address, fields);
  #ifdef ORDT_PIO_DRV_VERBOSE
     std::cout << "--> invalid path: " << pathstr << "\n";
  #endif
  return 4;
}

std::vector<std::string>  ordt_drv_element::get_tags() {
  std::vector<std::string> tags;
  tags.push_back("top");
  return tags;
}

int  ordt_drv_element::get_address(const std::string tag, const std::string pathstr, uint64_t &address, std::list<ordt_drv_field> &fields) {
  int version = get_version(tag);
  if (version<0) {
  #ifdef ORDT_PIO_DRV_VERBOSE
     std::cout << "--> invalid tag: " << tag << "\n";
  #endif
    return 2;
  }
  return get_address_using_version(version, pathstr, address, fields);
}

// ------------------ ordt_drv_regset_child methods ------------------

ordt_drv_regset_child::ordt_drv_regset_child(int _m_map, std::shared_ptr<ordt_drv_element> _m_child, int _m_reps, uint64_t _m_offset, uint64_t _m_stride)
  : m_map(_m_map),
    m_child(_m_child),
    m_reps(_m_reps),
    m_offset(_m_offset),
    m_stride(_m_stride) {
}

// ------------------ ordt_drv_regset methods ------------------

ordt_drv_regset::ordt_drv_regset(std::string _m_name)
  : ordt_drv_element(_m_name),
    m_children() {
}

int  ordt_drv_regset::get_address_using_list(const int version, std::list<ordt_drv_path_element> &path, const bool bypass_names, uint64_t &address, std::list<ordt_drv_field> &fields) {
  if (path.empty())
    return 8;
  ordt_drv_path_element pelem = path.front();
  if (!bypass_names) {
    path.pop_front();
    if (path.empty())
      return 0;
    pelem = path.front();
  }
  for (auto const &child: m_children) {
    if (((1<<version) & child.m_map) && (bypass_names || (pelem.m_name == child.m_child->m_name))) {
      address += child.m_offset;
      if (child.m_reps>1) address += (child.m_stride*pelem.m_idx);
      return child.m_child->get_address_using_list(version, path, false, address, fields);
    }
  }
  #ifdef ORDT_PIO_DRV_VERBOSE
  std::cout << "--> unable to find child " << pelem.m_name << " in regset " << m_name << "\n";
  #endif
  return 8;
}

void  ordt_drv_regset::add_child(int _m_map, std::shared_ptr<ordt_drv_element> _m_child, int _m_reps, uint64_t _m_offset, uint64_t _m_stride) {
  ordt_drv_regset_child new_child(_m_map, _m_child, _m_reps, _m_offset, _m_stride);
  m_children.push_back(new_child);
}

// ------------------ ordt_drv_reg methods ------------------

ordt_drv_reg::ordt_drv_reg(std::string _m_name)
  : ordt_drv_element(_m_name),
    m_fields() {
}

int  ordt_drv_reg::get_address_using_list(const int version, std::list<ordt_drv_path_element> &path, const bool bypass_names, uint64_t &address, std::list<ordt_drv_field> &fields) {
  if (path.empty())
    return 8;
  path.pop_front();
  if (path.empty()) {
    fields = m_fields;
    return 0;
  }
  #ifdef ORDT_PIO_DRV_VERBOSE
  ordt_drv_path_element pelem = path.front();
  std::cout << "--> invalid child " << pelem.m_name << " specified in reg " << m_name << "\n";
  #endif
  return 8;
}

void  ordt_drv_reg::add_field(std::string _m_name, int _m_loidx, int _width, bool _m_readable, bool _m_writeable) {
  ordt_drv_field new_field(_m_name, _m_loidx, _width, _m_readable, _m_writeable);
  m_fields.push_back(new_field);
}

// ------------------ ordt_drv_root methods ------------------

ordt_drv_root::ordt_drv_root()
  : ordt_drv_regset("root") {
  build();
}

void  ordt_drv_root::build() {
  std::shared_ptr<ordt_drv_reg> reg_dbg_mon_8 = std::make_shared<ordt_drv_reg>("reg_dbg_mon");
  reg_dbg_mon_8->add_field("mfe_debug_enabled", 1, 1, true, false);
  reg_dbg_mon_8->add_field("ncr_debug_enabled", 2, 1, true, false);
  std::shared_ptr<ordt_drv_reg> reg_cal_fail_35 = std::make_shared<ordt_drv_reg>("reg_cal_fail");
  reg_cal_fail_35->add_field("all_mem_cal_success", 0, 8, true, false);
  reg_cal_fail_35->add_field("all_mem_cal_fail", 8, 8, true, false);
  std::shared_ptr<ordt_drv_reg> reg_amm_2_18 = std::make_shared<ordt_drv_reg>("reg_amm_2");
  reg_amm_2_18->add_field("amm_2_read_req", 0, 32, true, false);
  reg_amm_2_18->add_field("amm_2_read_rsp", 32, 32, true, false);
  std::shared_ptr<ordt_drv_reg> reg_ndlt_6_31 = std::make_shared<ordt_drv_reg>("reg_ndlt_6");
  reg_ndlt_6_31->add_field("avs_ndlt_6_read_req", 0, 32, true, false);
  reg_ndlt_6_31->add_field("avs_ndlt_6_read_rsp", 32, 32, true, false);
  std::shared_ptr<ordt_drv_reg> reg_msp_size_4 = std::make_shared<ordt_drv_reg>("reg_msp_size");
  reg_msp_size_4->add_field("msp_size", 0, 2, true, true);
  std::shared_ptr<ordt_drv_reg> reg_amm_3_19 = std::make_shared<ordt_drv_reg>("reg_amm_3");
  reg_amm_3_19->add_field("amm_3_read_req", 0, 32, true, false);
  reg_amm_3_19->add_field("amm_3_read_rsp", 32, 32, true, false);
  std::shared_ptr<ordt_drv_reg> reg_ndlt_7_32 = std::make_shared<ordt_drv_reg>("reg_ndlt_7");
  reg_ndlt_7_32->add_field("avs_ndlt_7_read_req", 0, 32, true, false);
  reg_ndlt_7_32->add_field("avs_ndlt_7_read_rsp", 32, 32, true, false);
  std::shared_ptr<ordt_drv_reg> reg_ndlt_0_25 = std::make_shared<ordt_drv_reg>("reg_ndlt_0");
  reg_ndlt_0_25->add_field("avs_ndlt_0_read_req", 0, 32, true, false);
  reg_ndlt_0_25->add_field("avs_ndlt_0_read_rsp", 32, 32, true, false);
  std::shared_ptr<ordt_drv_reg> reg_type_node_2 = std::make_shared<ordt_drv_reg>("reg_type_node");
  reg_type_node_2->add_field("absolute_node_number", 0, 16, true, true);
  reg_type_node_2->add_field("condor_system", 16, 1, true, true);
  std::shared_ptr<ordt_drv_reg> reg_ncr_reg_34 = std::make_shared<ordt_drv_reg>("reg_ncr_reg");
  reg_ncr_reg_34->add_field("avs_ncr_regif_read_req", 0, 32, true, false);
  reg_ncr_reg_34->add_field("avs_ncr_regif_read_rsp", 32, 32, true, false);
  std::shared_ptr<ordt_drv_reg> reg_ign_pa_10 = std::make_shared<ordt_drv_reg>("reg_ign_pa");
  reg_ign_pa_10->add_field("ignore_phy_addr", 0, 1, true, true);
  std::shared_ptr<ordt_drv_reg> reg_ndlt_1_26 = std::make_shared<ordt_drv_reg>("reg_ndlt_1");
  reg_ndlt_1_26->add_field("avs_ndlt_1_read_req", 0, 32, true, false);
  reg_ndlt_1_26->add_field("avs_ndlt_1_read_rsp", 32, 32, true, false);
  std::shared_ptr<ordt_drv_reg> reg_amm_4_20 = std::make_shared<ordt_drv_reg>("reg_amm_4");
  reg_amm_4_20->add_field("amm_4_read_req", 0, 32, true, false);
  reg_amm_4_20->add_field("amm_4_read_rsp", 32, 32, true, false);
  std::shared_ptr<ordt_drv_reg> reg_hilo_14 = std::make_shared<ordt_drv_reg>("reg_hilo");
  reg_hilo_14->add_field("dsp_lo", 0, 1, true, true);
  reg_hilo_14->add_field("dsp_hi", 1, 1, true, true);
  std::shared_ptr<ordt_drv_reg> reg_amm_5_21 = std::make_shared<ordt_drv_reg>("reg_amm_5");
  reg_amm_5_21->add_field("amm_5_read_req", 0, 32, true, false);
  reg_amm_5_21->add_field("amm_5_read_rsp", 32, 32, true, false);
  std::shared_ptr<ordt_drv_reg> reg_ndlt_2_27 = std::make_shared<ordt_drv_reg>("reg_ndlt_2");
  reg_ndlt_2_27->add_field("avs_ndlt_2_read_req", 0, 32, true, false);
  reg_ndlt_2_27->add_field("avs_ndlt_2_read_rsp", 32, 32, true, false);
  std::shared_ptr<ordt_drv_reg> reg_cdt2_13 = std::make_shared<ordt_drv_reg>("reg_cdt2");
  reg_cdt2_13->add_field("node_threads", 0, 16, true, false);
  reg_cdt2_13->add_field("enable_credits", 32, 1, true, true);
  reg_cdt2_13->add_field("track_migration", 63, 1, true, true);
  std::shared_ptr<ordt_drv_reg> reg_cores_cluster_6 = std::make_shared<ordt_drv_reg>("reg_cores_cluster");
  reg_cores_cluster_6->add_field("cores_per_cluster", 0, 4, true, false);
  std::shared_ptr<ordt_drv_reg> reg_rt_ctr_9 = std::make_shared<ordt_drv_reg>("reg_rt_ctr");
  reg_rt_ctr_9->add_field("real_time_counter", 0, 64, true, true);
  std::shared_ptr<ordt_drv_reg> reg_cdt1_12 = std::make_shared<ordt_drv_reg>("reg_cdt1");
  reg_cdt1_12->add_field("node_credits", 0, 16, true, true);
  reg_cdt1_12->add_field("overwrite_credits", 63, 1, true, true);
  std::shared_ptr<ordt_drv_reg> reg_amm_6_22 = std::make_shared<ordt_drv_reg>("reg_amm_6");
  reg_amm_6_22->add_field("amm_6_read_req", 0, 32, true, false);
  reg_amm_6_22->add_field("amm_6_read_rsp", 32, 32, true, false);
  std::shared_ptr<ordt_drv_reg> reg_ndlt_3_28 = std::make_shared<ordt_drv_reg>("reg_ndlt_3");
  reg_ndlt_3_28->add_field("avs_ndlt_3_read_req", 0, 32, true, false);
  reg_ndlt_3_28->add_field("avs_ndlt_3_read_rsp", 32, 32, true, false);
  std::shared_ptr<ordt_drv_reg> reg_bar2_37 = std::make_shared<ordt_drv_reg>("reg_bar2");
  reg_bar2_37->add_field("max_wait_delay_bar2", 0, 17, true, false);
  reg_bar2_37->add_field("sc_bar2_read_burst_set", 32, 6, true, false);
  reg_bar2_37->add_field("sc_bar2_write_burst_set", 40, 6, true, false);
  std::shared_ptr<ordt_drv_reg> reg_avl_mon_7 = std::make_shared<ordt_drv_reg>("reg_avl_mon");
  reg_avl_mon_7->add_field("enable_pcie_read", 0, 1, true, true);
  reg_avl_mon_7->add_field("avalon_monitor_bypass0", 8, 1, true, true);
  reg_avl_mon_7->add_field("avalon_monitor_bypass2", 9, 1, true, true);
  reg_avl_mon_7->add_field("avalon_timeout_bar0", 16, 16, true, true);
  reg_avl_mon_7->add_field("avalon_timeout_bar2", 32, 16, true, true);
  std::shared_ptr<ordt_drv_reg> reg_bar0_36 = std::make_shared<ordt_drv_reg>("reg_bar0");
  reg_bar0_36->add_field("max_wait_delay_bar0", 0, 17, true, false);
  std::shared_ptr<ordt_drv_reg> reg_avs_sc_24 = std::make_shared<ordt_drv_reg>("reg_avs_sc");
  reg_avs_sc_24->add_field("avs_sc_read_req", 0, 32, true, false);
  reg_avs_sc_24->add_field("avs_sc_read_rsp", 32, 32, true, false);
  std::shared_ptr<ordt_drv_reg> reg_rst_15 = std::make_shared<ordt_drv_reg>("reg_rst");
  reg_rst_15->add_field("reset_cluster", 0, 4, true, true);
  reg_rst_15->add_field("reset_msp", 4, 4, true, true);
  reg_rst_15->add_field("reset_me", 8, 1, true, true);
  reg_rst_15->add_field("reset_emif", 16, 8, true, true);
  reg_rst_15->add_field("reset_srio", 24, 6, true, true);
  reg_rst_15->add_field("reset_srio_control", 30, 1, true, true);
  std::shared_ptr<ordt_drv_reg> reg_me_reg_33 = std::make_shared<ordt_drv_reg>("reg_me_reg");
  reg_me_reg_33->add_field("avs_me_regif_read_req", 0, 32, true, false);
  reg_me_reg_33->add_field("avs_me_regif_read_rsp", 32, 32, true, false);
  std::shared_ptr<ordt_drv_reg> reg_dis_ls_11 = std::make_shared<ordt_drv_reg>("reg_dis_ls");
  reg_dis_ls_11->add_field("disable_local_spawn", 0, 1, true, true);
  std::shared_ptr<ordt_drv_reg> reg_amm_0_16 = std::make_shared<ordt_drv_reg>("reg_amm_0");
  reg_amm_0_16->add_field("amm_0_read_req", 0, 32, true, false);
  reg_amm_0_16->add_field("amm_0_read_rsp", 32, 32, true, false);
  std::shared_ptr<ordt_drv_reg> reg_ndlt_4_29 = std::make_shared<ordt_drv_reg>("reg_ndlt_4");
  reg_ndlt_4_29->add_field("avs_ndlt_4_read_req", 0, 32, true, false);
  reg_ndlt_4_29->add_field("avs_ndlt_4_read_rsp", 32, 32, true, false);
  std::shared_ptr<ordt_drv_reg> reg_amm_7_23 = std::make_shared<ordt_drv_reg>("reg_amm_7");
  reg_amm_7_23->add_field("amm_7_read_req", 0, 32, true, false);
  reg_amm_7_23->add_field("amm_7_read_rsp", 32, 32, true, false);
  std::shared_ptr<ordt_drv_reg> reg_clst_msp_5 = std::make_shared<ordt_drv_reg>("reg_clst_msp");
  reg_clst_msp_5->add_field("num_msps", 0, 4, true, false);
  reg_clst_msp_5->add_field("num_clusters", 32, 4, true, false);
  std::shared_ptr<ordt_drv_reg> reg_ndlt_5_30 = std::make_shared<ordt_drv_reg>("reg_ndlt_5");
  reg_ndlt_5_30->add_field("avs_ndlt_5_read_req", 0, 32, true, false);
  reg_ndlt_5_30->add_field("avs_ndlt_5_read_rsp", 32, 32, true, false);
  std::shared_ptr<ordt_drv_reg> reg_num_nodes_3 = std::make_shared<ordt_drv_reg>("reg_num_nodes");
  reg_num_nodes_3->add_field("log2_num_nodes", 0, 5, true, true);
  std::shared_ptr<ordt_drv_reg> reg_amm_1_17 = std::make_shared<ordt_drv_reg>("reg_amm_1");
  reg_amm_1_17->add_field("amm_1_read_req", 0, 32, true, false);
  reg_amm_1_17->add_field("amm_1_read_rsp", 32, 32, true, false);
  std::shared_ptr<ordt_drv_regset> node_1 = std::make_shared<ordt_drv_regset>("node");
  node_1->add_child(1, reg_dbg_mon_8, 1, 48, 4);
  node_1->add_child(1, reg_cal_fail_35, 1, 256, 8);
  node_1->add_child(1, reg_amm_2_18, 1, 120, 8);
  node_1->add_child(1, reg_ndlt_6_31, 1, 224, 8);
  node_1->add_child(1, reg_msp_size_4, 1, 16, 8);
  node_1->add_child(1, reg_amm_3_19, 1, 128, 8);
  node_1->add_child(1, reg_ndlt_7_32, 1, 232, 8);
  node_1->add_child(1, reg_ndlt_0_25, 1, 176, 8);
  node_1->add_child(1, reg_type_node_2, 1, 0, 8);
  node_1->add_child(1, reg_ncr_reg_34, 1, 248, 8);
  node_1->add_child(1, reg_ign_pa_10, 1, 64, 4);
  node_1->add_child(1, reg_ndlt_1_26, 1, 184, 8);
  node_1->add_child(1, reg_amm_4_20, 1, 136, 8);
  node_1->add_child(1, reg_hilo_14, 1, 88, 4);
  node_1->add_child(1, reg_amm_5_21, 1, 144, 8);
  node_1->add_child(1, reg_ndlt_2_27, 1, 192, 8);
  node_1->add_child(1, reg_cdt2_13, 1, 80, 8);
  node_1->add_child(1, reg_cores_cluster_6, 1, 32, 8);
  node_1->add_child(1, reg_rt_ctr_9, 1, 56, 8);
  node_1->add_child(1, reg_cdt1_12, 1, 72, 8);
  node_1->add_child(1, reg_amm_6_22, 1, 152, 8);
  node_1->add_child(1, reg_ndlt_3_28, 1, 200, 8);
  node_1->add_child(1, reg_bar2_37, 1, 272, 8);
  node_1->add_child(1, reg_avl_mon_7, 1, 40, 8);
  node_1->add_child(1, reg_bar0_36, 1, 264, 8);
  node_1->add_child(1, reg_avs_sc_24, 1, 168, 8);
  node_1->add_child(1, reg_rst_15, 1, 96, 8);
  node_1->add_child(1, reg_me_reg_33, 1, 240, 8);
  node_1->add_child(1, reg_dis_ls_11, 1, 68, 4);
  node_1->add_child(1, reg_amm_0_16, 1, 104, 8);
  node_1->add_child(1, reg_ndlt_4_29, 1, 208, 8);
  node_1->add_child(1, reg_amm_7_23, 1, 160, 8);
  node_1->add_child(1, reg_clst_msp_5, 1, 24, 8);
  node_1->add_child(1, reg_ndlt_5_30, 1, 216, 8);
  node_1->add_child(1, reg_num_nodes_3, 1, 8, 8);
  node_1->add_child(1, reg_amm_1_17, 1, 112, 8);
  std::shared_ptr<ordt_drv_regset> top_0 = std::make_shared<ordt_drv_regset>("top");
  top_0->add_child(1, node_1, 1, 2097152, 512);
  add_child(1, top_0, 1, 0, 0);
}

int  ordt_drv_root::get_address_using_version(const int version, const std::string pathstr, uint64_t &address, std::list<ordt_drv_field> &fields) {
  address=0;
  fields.clear();
  std::list<ordt_drv_path_element> path = get_path(pathstr);
  if (path.size()>0) return get_address_using_list(version, path, true, address, fields);
  #ifdef ORDT_PIO_DRV_VERBOSE
     std::cout << "--> invalid path: " << pathstr << "\n";
  #endif
  return 4;
}

